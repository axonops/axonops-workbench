/**
 * Module to handle the `app-config.cfg` read and write processes
 * It's also used in the renderer thread
 *
 *
 * Import modules, and define constants
 *
 * Implements a configuration file parser
 * The structure is very similar to the Windows `.ini` file
 */

const defaultConfig = `[security]
contentProtection=false
loggingEnabled=true

[ui]
theme=light
language=en
hideAboutDialog=true

[limit]
sandbox=1
cqlsh=10

[sshtunnel]
readyTimeout=60000
forwardTimeout=60000
`

const dataPath = Path.join(process.env.APPDATA || (process.platform === 'darwin' ? process.env.HOME + '/Library/Application Support' : process.env.HOME + "/.config"), 'AxonOpsCassandra')
if (!FS.existsSync(dataPath)) {
  try {
    FS.mkdirSync(dataPath, { recursive: true });
    console.log(`Created logs directory: ${dataPath}`);
  } catch (err) {
    console.error(`Error creating logs directory: ${err.message}`);
  }
}

// Define `app-config.json` file path
const AppConfigPath = Path.join(dataPath, 'app-config.cfg')

// Check if the file exists
FS.access(AppConfigPath, FS.constants.F_OK, (err) => {
  if (err) {
    // File doesn't exist, so create it with the default config
    FS.writeFile(AppConfigPath, defaultConfig, 'utf8', (writeErr) => {
      if (writeErr) {
        console.error('Error writing config file:', writeErr);
      } else {
        console.log('Config file created successfully.');
      }
    });
  } else {
    console.log('Config file already exists. No changes made.');
  }
})

ConfigParser = require('configparser')

/**
 * Get the app's configuration properties
 *
 * @Parameters:
 * {object} `callback` function that will be triggered with passing the final configuration object
 *
 * @Return: {object} either `null` or the configuration object
 */
let getConfig = (callback) => {
  try {
    // Add log about this process
    try {
      addLog(`Retrieve the app's configuration from 'app-config.cfg' file`, 'process')
    } catch (e) {}

    console.log(AppConfigPath)
    // Create a config parser object
    let configObject = new ConfigParser()

    // Read the app configuration file
    configObject.read(AppConfigPath)

    // Call the `callback` function with passing the configuration object
    return callback(configObject)
  } catch (e) {
    try {
      // If the error is a number then don't log the error
      if (!isNaN(parseInt(e.toString())))
        throw 0

      addLog(`Error in process configuration. Details: ${e}`, 'error')
    } catch (e) {}

    // If any error has occurred then call the `callback` function with passing `null` to indicate a failure
    return callback(null)
  }
}

/**
 * Set the given configuration object content in the app's config file
 *
 * @Parameters:
 * {object} `configObject` the configuration object
 */
let setConfig = (configObject) => {
  // Add log about this process
  try {
    addLog(`Write/update the app's configuration to file 'app-config.cfg'`, 'process')
  } catch (e) {}

  // Attempt to set/write the given configuration object in the app's config file
  try {
    configObject.write(AppConfigPath)
  } catch (e) {
    try {
      // If the error is a number then don't log the error
      if (!isNaN(parseInt(e.toString())))
        throw 0

      addLog(`Error in process configuration. Details: ${e}`, 'error')
    } catch (e) {}
  }
}


/**
 * Merge two config files by updating existing keys, add new sections and keys
 *
 * @Parameters:
 * {string} `oldConfigFilePath` the path of the old config file
 * {string} `newConfigFilePath` the path of the new config file
 * {object} `callback` function that will be triggered when the process is finished
 */
let mergeConfigFiles = (oldConfigFilePath, newConfigFilePath, callback) => {
  try {
    // Create a config parser object for the old config
    let oldConfigObject = new ConfigParser(),
      // Create a config parser object for the new config
      newConfigObject = new ConfigParser()

    // Read the old config file
    oldConfigObject.read(oldConfigFilePath)

    // Read the new config file
    newConfigObject.read(newConfigFilePath)

    // Get the sections from the new config file
    let newConfigSections = newConfigObject.sections()

    // Loop through each section
    for (let section of newConfigSections) {
      // Get the keys of the current section
      let keys = newConfigObject.items(section)

      // Loop through each key
      for (let key of Object.keys(keys)) {
        // Get the key's value from the old config file
        let oldValue = oldConfigObject.get(section, key)

        // If the key not exist in the old config file then skip it - the default value will be adopted -
        if (oldValue === undefined)
          continue

        // Set the old value in the new config file
        newConfigObject.set(section, key, oldValue)
      }
    }

    // Now write the new config file to the old one
    newConfigObject.write(oldConfigFilePath)
  } catch (e) {} finally {
    // Call the callback function
    callback()
  }
}

module.exports = {
  getConfig,
  setConfig,
  mergeConfigFiles
}
