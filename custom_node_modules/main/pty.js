/**
 * Module to handle all events, communication, and actions with `node-pty` module
 * `node-pty` is mainly used as a container to create a unique cqlsh for each session/connection
 *
 * Import modules
 *
 * Node.js path module
 * Working with file and directory paths
 */
const Path = require('path'),
  /**
   * PTY creation module
   * Creates pseudo terminal, it returns a terminal object that allows interaction - reads and writes - with that terminal
   */
  PTY = require('node-pty'),
  /**
   * Node.js OS module
   * Used for operating system-related utilities /and properties
   */
  OS = require('os'),
  // Execute commands across all platforms
  Terminal = require('node-cmd'),
  // Strip all special characters in a given string
  StripChar = require('stripchar').StripChar,
  // Return the absolute system-dependant path for the place where applications should store their data for the current user
  AppData = require('appdata-path'),
  /**
   * Module to fix a given JSON in string format
   * Used mostly within `print metadata` request
   */
  JSONRepair = require('jsonrepair').jsonrepair,
  // Kill all processes in the process tree, including the root process
  Kill = require('tree-kill'),
  /**
   * Node.js file system module - improved version which has methods that aren't included in the native `fs` module -
   * Used for working with files system, it provides related utilities
   */
  FS = require('fs-extra')

/**
 * Get platform (`win32`, `linux` or `darwin`)
 * Will be used a lot in the module
 */
const Platform = OS.platform(),
  /**
   * Choose the suitable shell based on the platform
   * For Linux and macOS we use `bash`, for Windows we use the `cmd`
   */
  Shell = Platform == 'win32' ? 'cmd.exe' : 'bash',
  /**
   * Define the suitable new line char based on the platform
   * This is important as appending this special char is equivalent to `Enter`
   */
  NewLineChar = Platform == 'win32' ? '\r' : '\n',
  // Point at the `bin` folder where we have all modified cqlsh versions - and other binary files -
  CWD = Path.join(__dirname, '..', '..', 'main', 'bin'),
  // Define variables path
  VariablesFilePath = {
    // Path of the manifest file in the app's root folder
    manifest: Path.join(__dirname, '..', '..', 'config', 'variables.json'),
    // Path of the values of the variables stored in the os config/appdata folder
    values: AppData('cassandra_workbench.variables')
  }

/**
 * The module is a class with different attributes and methods
 * With each session we create an instance from this class
 */
class Pty {
  constructor(window, data) {
    this.pty = PTY // `node-pty` module
    this.window = window // Window to interact with - send and receive requests -
    this.id = data.id // The cluster's ID which this instance is associated with
    this.cassandraVersion = data.version // Cassandra version passed from the renderer thread after the connection test
    this.logPath = data.logPath // Log file's path for the current instance
    this.workspaceID = data.workspaceID // Given workspace's ID; to get the proper variables based on the scope
    this.sendData = false // Whether or not send data to the renderer thread
    this.prepareToSendAgain = false // Whether or not stop sending data partially to the renderer process
    this.metadataPrintRequestID = '' // Store the ID of cluster's metadata print request
    this.cqlDescPrintRequestID = '' // Hold the ID of CQL description's fetch/print request
    this.getQueryTracingRequestID = '' // Store the ID of query tracing's result get request
    this.requestTimeout = null // Timeout to be triggered if we didn't get the final valid result for a request
    this.latestCommand = '' // Store the latest received command from the renderer process
    this.allOutput = '' // Store all output to catch `CQLSH-STARTED` keyword

    // Create the pty instance and set the bin folder as the current working directory
    this.process = this.pty.spawn(Shell, [], {
      cwd: CWD,
      useConpty: false
    })

    // If we've got secrets (username and password)
    this.secrets = data.secrets || null

    // If we've got SSH tunneling info
    this.ssh = data.ssh || null

    let main = this, // To be more comfortable about pointing at the main instance
      count = 0 // Counter to neglect data (like Python warnings)

    // Set a timeout function to be triggered if we don't get any chunk of the request's result within 5 seconds
    let setTimeOut = (requestID) => {
      main.requestTimeout = setTimeout(() => {
        // Once the timeout function is triggered send a `null` block to the renderer thread
        main.window.webContents.send(requestID, {
          block: null,
          clusterID: main.id
        })

        // Reset the `getQueryTracingRequestID` to empty; so pty can send data to the renderer thread again
        main.getQueryTracingRequestID = ''

        // Update `prepareToSendAgain` to `true`; to resume the sending process
        main.prepareToSendAgain = true
      }, 5000)
    }

    // Clear the timeout function and reset it if needed to
    let clearTimeOut = (requestID = null, reset = false) => {
      // Clear the timer
      try {
        clearTimeout(main.requestTimeout)
      } catch (e) {}

      // If no need to reset then we may skip the upcoming code
      if (!reset)
        return

      // Reset the timeout function again
      setTimeOut(requestID)
    }

    // Special function for Windows to clean a given command and make it able to be compared with
    let cleanCommand = (command) => {
      // Remove all terminal's special characters
      command = `${command}`.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '')

      // Lower the case of all characters in the command
      command = command.toLowerCase()
        // Get rid of extra weird unwanted characters and symbols
        .replace(/^(.*?>)/gm, '').replace(/\\n/gm, '').replace('�[0K�[0K�[?25h', '')
        // Get rid of start and end spaces
        .trim()

      // Return the final manipulated command
      return command
    }

    /**
     * Minify a given text by manipulating it, plus getting rid of new lines
     * This function has been implemented in the `funcs.js` file in the renderer thread
     */
    let minifyText = (text) => {
      // Define the regex expression to be created
      let regexs = ['\\n', '\\r']

      // Loop through each regex
      regexs.forEach((regex) => {
        // Create regex object
        regex = new RegExp(regex, 'g')

        // Execute the replication process
        text = `${text}`.replace(regex, '')
      })

      // Call the text manipulation function
      text = text.replace(/\s+/gm, '').toLowerCase()

      // Return final result
      return text
    }

    // When receiving any data from the instance, send it to the provided window
    main.process.on('data', (data) => {
      try {
        // Add the received data to the associated variable and catch the start keywords
        try {
          // If one of the keywords has been captured already then skip this try-catch block
          if (main.allOutput == 'ignore-text')
            throw 0

          // Add the received data to the variable
          main.allOutput += minifyText(data)

          // If any of the keywords have been found
          if ((['cqlsh-started', 'cqlsh>']).some((keyword) => main.allOutput.indexOf(keyword) != -1)) {
            // Add the ignore keyword
            main.allOutput = 'ignore-text'

            // Send the keyword to the renderer thread
            return main.window.webContents.send(`pty:data:${main.id}`, 'cqlsh-started')
          }
        } catch (e) {}

        // Increase the counter with every data/chunk received
        ++count

        // Prevent sending data - like warnings - while cqlsh is initializing
        if (count >= (Platform != 'darwin' ? 2 : 4))
          main.sendData = true

        // If we're not allowed yet to send data, or we must entirely stop sending data
        if (!main.sendData)
          return

        /**
         * Handle the request - from the renderer thread - to get a query tracing result
         * This request is being catched by having a value in `getQueryTracingRequestID` that has been set from `getQueryTracing` function
         */
        try {
          // If `getQueryTracingRequestID` is empty then we may skip this try-catch block
          if (main.getQueryTracingRequestID.length <= 0)
            throw 0

          // Define the request ID that the renderer thread `ipc` is listening to
          let requestID = `cluster:query-tracing:${main.getQueryTracingRequestID}`

          // Clear the timeout function with reset
          clearTimeOut(requestID, true)

          // Check if there's `(n rows) ` keyword in the given data then it means we've got all rows in the query tracing result and we may stop the process
          try {
            // If the keyword is not found then skip this try-catch block
            if ((new RegExp('cqlsh\s*(\:|\s*)(.+|\s*)\>')).exec(data) == null)
              throw 0

            /**
             * Reset the `getQueryTracingRequestID` to empty; so pty can send data to the renderer thread right after this process
             * Update `prepareToSendAgain` to `true`; to resume the sending process
             * Call the clear timeout function without reset
             */
            main.getQueryTracingRequestID = ''
            main.prepareToSendAgain = true
            clearTimeOut()
          } catch (e) {}

          // Send the tracing result in JSON block, attached with the cluster's ID
          main.window.webContents.send(requestID, {
            block: data,
            clusterID: main.id
          })

          // Skip the upcoming code
          return
        } catch (e) {}

        /**
         * Handle the request - from the renderer thread - to send the metadata info
         * This request is being catched by having a value in `metadataPrintRequestID` that has been set from the `getMetadata` function
         */
        try {
          // If `metadataPrintRequestID` is empty then we may skip this try-catch block
          if (main.metadataPrintRequestID.length <= 0)
            throw 0

          /**
           * Reset the `metadataPrintRequestID` and `metadataBlock` to empty; so pty can send data to the renderer thread again
           * Update `prepareToSendAgain` to `true`; to resume the sending process
           * Call the clear timeout function without reset
           */
          main.metadataPrintRequestID = ''
          main.prepareToSendAgain = true

          // Skip the upcoming code
          return
        } catch (e) {}

        /**
         * Handle the request - from the renderer thread - to get a CQL description of the specific scope
         * This request is being catched by having a value in `cqlDescPrintRequestID` that has been set from the `getCQLDescription` function
         */
        try {
          // If `cqlDescPrintRequestID` is empty then we may skip this try-catch block
          if (main.cqlDescPrintRequestID.length <= 0)
            throw 0

          /**
           * Reset the `cqlDescPrintRequestID` to empty; so pty can send data to the renderer thread again
           * Update `prepareToSendAgain` to `true`; to resume the sending process
           * Call the clear timeout function without reset
           */
          main.cqlDescPrintRequestID = ''
          main.prepareToSendAgain = true

          // Skip the upcoming code
          return
        } catch (e) {}

        // When `prepareToSendAgain` is set to `true` then we only stop once, and then back again to send data
        if (main.prepareToSendAgain)
          return main.prepareToSendAgain = false

        // Make sure to not send the command that the user has typed already and requested to be executed
        let dataManipulated = data,
          latestCommand = main.latestCommand

        try {
          // If the current OS is not Windows then throw an error and adopt the other way of manipulating the commands
          if (Platform != 'win32')
            throw 0

          // Clean the commands in special way only for Windows
          dataManipulated = cleanCommand(dataManipulated)
          latestCommand = cleanCommand(latestCommand)
        } catch (e) {
          // Clean the commands for Linux and macOS
          dataManipulated = StripChar.RSExceptUnsAlpNum(data)
          latestCommand = StripChar.RSExceptUnsAlpNum(main.latestCommand)
        }

        // If true, don't send that data to the renderer thread
        if ((dataManipulated == latestCommand) && main.latestCommand.trim().length != 0)
          return

        // Send data from cqlsh to the renderer thread
        main.window.webContents.send(`pty:data:${main.id}`, data)
      } catch (e) {}
    })
  }

  // Send command to the pty instance
  command(command) {
    // If the command is one of the array's items then we'll stop sending data, and destroy the pty instance
    if ((['quit', 'exit']).some((keyword) => command.toLowerCase().startsWith(keyword)))
      this.sendData = false

    // Update the latest command
    this.latestCommand = command

    // Send the command to the pty instance
    this.process.write(command + NewLineChar)
  }

  // Close, kill and destroy the pty instance, furthermore, kill the instance using a different approach by its process ID
  close() {
    try {
      // Call the `destroy` function from the pty instance
      this.process.destroy()

      // Attempt to kill the pty instance process by its process ID
      Kill(this.process.pid, 'SIGKILL')
    } catch (e) {}
  }

  // Pause the socket which connects between the pty instance and the renderer thread
  pause() {
    this.process.pause()
  }

  // Resume the socket
  resume() {
    this.process.resume()
  }

  /**
   * Create a cqlsh instance by passing the `cqlsh.rc` file's path
   * The proper cqlsh version will be called based on the given Apache Cassandra's version
   */
  createCQLSHInstance(cqlshrcPath) {
    // By default, cqlsh `v6.0.0` will be used to connect with the cluster
    let cqlsh = '407',
      // Define the Apache Cassandra's version
      version = this.cassandraVersion

    // Check Cassandra's version, and choose the suitable cqlsh version to be called
    cqlsh = version.startsWith('4.1') ? '410' : cqlsh

    // Make sure it is executable on Linux and macOS
    if (Platform != 'win32')
      Terminal.runSync(`cd '${CWD}' && chmod +x cqlsh-${cqlsh}`)

    // Run cqlsh instance with the given cqlsh file path
    let binCall = `./cqlsh-${cqlsh}`

    // If the host is Windows then change the binary call format
    binCall = Platform == 'win32' ? (`cqlsh-${cqlsh}.exe`) : binCall

    // If there are more arguments to be passed - like username and password -
    let moreArguments = ''
    try {
      // If not, then we may skip this try-catch block
      if ([null, undefined].includes(this.secrets))
        throw 0

      // Otherwise, secrets will be passed as arguments
      moreArguments += `--username="${this.secrets.username}" `
      moreArguments += `--password="${this.secrets.password}" `
    } catch (e) {}

    // Check if SSH tunneling info has been given
    let override = ''
    try {
      // If not, then we may skip this try-catch block
      if ([null, undefined].includes(this.ssh))
        throw 0

      // Otherwise, SSH info will be passed with the execution command
      override += `127.0.0.1 ${this.ssh.port} `
      override += `--overrideHost="${this.ssh.host}" `
      override += `--overridePort="${this.ssh.oport}" `
    } catch (e) {}

    // Check if adding a cmd command to change the code page is required
    let pageCode = Platform == 'win32' ? 'chcp 65001 && ' : ''

    // Run the cqlsh's executing command
    this.command(`${pageCode}${binCall} ${override} --cqlshrc="${cqlshrcPath}" ${moreArguments} --log="${this.logPath}" --varsManifest="${VariablesFilePath.manifest}" --varsValues="${VariablesFilePath.values}" --workspaceID="${this.workspaceID}"`)
  }

  /**
   * Get the connected-to cluster's metadata
   * The process is handled in the `constructor` function as we've executed the `print` command
   */
  getMetadata(metadataPrintRequestID) {
    // We change the value of `metadataPrintRequestID`; so when we receive data from cqlsh it'll be handled within the `print metadata` request
    this.metadataPrintRequestID = metadataPrintRequestID
    this.command(`print metadata (${metadataPrintRequestID})`)

    // Define the request ID that the renderer thread is listening to
    let requestID = `cluster:metadata:${this.metadataPrintRequestID}:${this.id}`,
      // Define the temp file path; to be watched once it's created
      tempFile = Path.join(OS.tmpdir(), `${this.metadataPrintRequestID}.metadata`)

    // Watch the temp file existence
    watchFileExistance(tempFile, async (found) => {
      // If the file not found for any reason then send `null` result to the renderer thread
      if (!found) {
        this.window.webContents.send(requestID, {
          metadata: null,
          clusterID: this.id
        })

        // Skip the upcoming code
        return
      }

      // Read the file's content
      let metadataContent = await FS.readFileSync(tempFile, 'utf8')

      // Send the metadata JSON block, attached with the cluster's ID
      this.window.webContents.send(requestID, {
        metadata: metadataContent,
        clusterID: this.id
      })

      // Remove the temp file
      try {
        FS.unlinkSync(tempFile)
      } catch (e) {}
    })
  }

  /**
   * Get a CQL description of the connected-to cluster, keyspace in it, or a table
   * The process is handled in the `constructor` function as we've executed the `print` command
   */
  getCQLDescription(cqlDescPrintRequestID, scope) {
    // We change the value of `cqlDescPrintRequestID`; so when we receive data from cqlsh it'll be handled within the `print cql_desc` request
    this.cqlDescPrintRequestID = cqlDescPrintRequestID
    this.command(`print cql_desc (${cqlDescPrintRequestID}) (${scope})`)

    // Define the request ID that the renderer thread is listening to
    let requestID = `cluster:cql-desc:${this.cqlDescPrintRequestID}:${this.id}`,
      // Define the temp file path; to be watched once it's created
      tempFile = Path.join(OS.tmpdir(), `${this.cqlDescPrintRequestID}.cqldesc`)

    // Watch the temp file existence
    watchFileExistance(tempFile, async (found) => {
      // If the file is not found for any reason then send the `null` result to the renderer thread
      if (!found) {
        this.window.webContents.send(requestID, {
          cqlDesc: null,
          clusterID: this.id
        })

        // Skip the upcoming code
        return
      }

      // Read the file's content
      let cqlDescContent = await FS.readFileSync(tempFile, 'utf8')

      // Send the cqlDesc JSON block, attached with the cluster's ID
      this.window.webContents.send(requestID, {
        cqlDesc: cqlDescContent,
        clusterID: this.id
      })

      // Remove the temp file
      try {
        FS.unlinkSync(tempFile)
      } catch (e) {}
    })
  }

  /**
   * Get a query tracing's result for a session by passing its ID
   * The process is handled in the `constructor` function as we've executed the related statement
   */
  getQueryTracing(requestID, sessionID) {
    // We change the value of `getQueryTracingRequestID`; so when we receive data from cqlsh it'll be handled within the query tracing request
    this.getQueryTracingRequestID = requestID
    this.command('select JSON * from system_traces.events where session_id = ' + sessionID + ';')
  }
}

// Test connection with a given cluster based on its `cqlsh.rc` file
let testConnectionWithCluster = (window, data) => {
  // Final test result which be returned
  let result = {
      connected: false, // Connection status - `false`: failed, `true`: succeed - with the cluster
      version: '-' // Apache Cassandra's version
    },
    // If we've got JSON string then the connection test has succeeded
    gotJSON = false,
    // Used to prevent sending the test result more than once
    resultSent = false,
    // Counter; to make sure that a response will be sent for sure after 4 received data blocks
    count = 0,
    // Save the last given output; so we can track the connection process and detect errors
    lastOutput = '',
    // Whether or not send the test's final result
    send = false,
    // Send time out to be triggered within 5 seconds
    sendTimeout = null,
    // All output from the testing process is appended here
    fullOutput = ''

  // There might be duplicated code here; as this function is isolated from the Pty class
  try {
    // Create a temporary pty instance that will contain cqlsh instance
    let tempProcess = PTY.spawn(Shell, [], {
      cwd: CWD,
      useConpty: false
    })

    /**
     * Make sure `cqlsh-407` is in execution mode before using it
     * For test connection we always use cqlsh v5.0.1
     */
    if (Platform != 'win32')
      Terminal.runSync(`cd "${CWD}" && chmod +x cqlsh-407`)

    // If the host is Windows then change the binary call format
    let binCall = Platform == 'win32' ? 'cqlsh-407.exe' : './cqlsh-407'

    // If there are more arguments to be passed - like username and password -
    let moreArguments = ''
    try {
      // If not, then we may skip this try-catch block
      if ([null, undefined].includes(data.secrets))
        throw 0

      // Otherwise, secrets will be passed as arguments
      moreArguments += `--username="${data.secrets.username}" `
      moreArguments += `--password="${data.secrets.password}" `
    } catch (e) {}

    // Check if we've got a port to override the given one in `cqlsh.rc`
    let override = ''
    if (data.port != undefined)
      override = `127.0.0.1 ${data.port}`

    // Check if adding a change code page command is required
    let pageCode = Platform == 'win32' ? 'chcp 65001 && ' : ''

    // `test` flag has been added to the command; to tell cqlsh to just test the connection, then end that connection and quit
    tempProcess.write(`${pageCode}${binCall} ${override} --cqlshrc="${data.cqlshrcPath}" ${moreArguments} --test 1 --varsManifest="${VariablesFilePath.manifest}" --varsValues="${VariablesFilePath.values}" --workspaceID="${data.workspaceID}"` + NewLineChar)

    // With every received data
    tempProcess.on('data', async (output) => {
      // If the output contains any of the strings then it won't be count
      if (['bin', 'bash', 'zsh'].every((str) => output.toLowerCase().indexOf(str) <= -1))
        ++count // Increment the counter

      // Append the output's content
      fullOutput += `${output}`

      // Get rid of new line and line breaks
      fullOutput = fullOutput.replace(/\n/g, '')
      fullOutput = fullOutput.replace(/\r/g, '')

      // Check the output in overall; to determine if the testing process has finished or not
      checkOutput(output)
    })

    let checkOutput = (output) => {
      // If a JSON object has been given then skip the checking process
      if (gotJSON)
        return

      // If `--cqlshrc` has been catched in the output then it means something went wrong with the test and we weren't able to make the test process
      if (lastOutput.indexOf('--cqlshrc') != -1 || lastOutput.match(/\-\-[a-z]+/gm) != null)
        lastOutput = 'Unable to make the test process'

      // Set the manipulated output as the last output if it has met the conditions
      if (output.toLowerCase().indexOf('active code') <= 0 && output.length > 5 && ['bin', 'bash', 'zsh'].every((str) => output.indexOf(str) <= -1))
        lastOutput = output.replace('TEST-COMPLETED', '')

      // Replace non-ascii chars, except the common ones - like brackets and colon -
      lastOutput = lastOutput.replace(/[^\x20-\x7E()[\]:,"']/g, '')

      // Replace `[K` char which can be printed in Windows cmd
      lastOutput = lastOutput.replace(/\[K/g, '')

      // If this try-catch block has been executed without errors then it means we've got JSON data and we may send the data and end the test process
      try {
        // We deal with the given data as JSON string by default
        let jsonString = fullOutput.match(/\{[\s\S]+\}/gm)[0]

        // Remove some added chars from cqlsh tool and repair the JSON to make sure it can be converted to JSON object easily
        jsonString = jsonString.replace(/u\'/gm, "'")
        jsonString = JSONRepair(jsonString)

        // Convert JSON content from string to object
        let jsonObject = JSON.parse(jsonString)

        /**
         * The test connection has been completed with success
         * We can get the Apache Cassandra version that we've connected with
         */
        result.connected = true
        result.version = jsonObject.build

        // If the version is `undefined` then it happens that the output split into multiple lines
        if (result.version == undefined)
          result.version = jsonObject[0].build

        // Get the cluster's data center
        result.datacenter = jsonObject.datacenter

        // Do the same thing - as the version - with the data center
        if (result.datacenter == undefined)
          result.datacenter = jsonObject[0].datacenter

        // Set `gotJSON` to true to end the connection test
        gotJSON = true
      } catch (e) {}

      // Inner function to send the test's result
      let sendResult = () => {
        // If the condition is `true` then send the test result to the renderer thread
        window.webContents.send(`pty:test-connection:${data.requestID}`, {
          ...result,
          error: lastOutput
        })

        // Update `resultSent` to prevent sending the test result more than once
        resultSent = true

        // To be more sure about ending the testing process 3 attempts (300ms in total) is executed; to kill the pty process by its pid
        try {
          let tries = 0,
            interval = setInterval(() => {
              if (tries > 2)
                return clearInterval(interval); // This semicolon is critical here

              ++tries
              try {
                // Call the `destroy` function from the pty instance
                tempProcess.destroy()

                // Attempt to kill the pty instance process by its process ID
                Kill(tempProcess.pid, 'SIGKILL')
              } catch (e) {}
            }, 100)
        } catch (e) {}
      }

      // Either we've got a valid JSON string or catched the `TEST-COMPLETED` keyword or an error has occurred, and the test's result is not yet sent to the renderer thread
      if ((gotJSON || (fullOutput.indexOf('TEST-COMPLETED') != -1) || (fullOutput.toLowerCase().indexOf('error') != -1)) && !resultSent) {
        // If we need to send the results now
        if (send) {
          // Clear the timeout function
          clearTimeout(sendTimeout)

          // Call the send function
          sendResult()

          // Skip the upcoming code
          return
        }

        // Update `send` to `true`; to send the results next time or within 5 seconds
        send = true

        // Set timeout to be triggered within 5 seconds if there's no more output
        sendTimeout = setTimeout(() => sendResult(), 2500)
      }
    }
  } catch (e) {
    window.webContents.send(`pty:test-connection:${data.requestID}`, {
      ...result,
      error: lastOutput
    })
  }
}

// Watch a given file and callback once it's exists
let watchFileExistance = (filePath, callback, startTime = new Date().getTime()) => {
  try {
    // Once it exists return `true` with the callback function
    if (FS.existsSync(filePath))
      return callback(true)

    throw 0
  } catch (e) {
    // Get current time
    let time = new Date().getTime()

    /**
     * Maximum watch time is 30 seconds
     * If the watcher failed to see the file within the specific time then it'll return `false` with the callback function
     */
    if ((time - startTime) >= 30000)
      return callback(false)

    // Make the process executed recursively
    setTimeout(() => watchFileExistance(filePath, callback, startTime), 1000)
  }
}

/**
 * Handle the creation of a Bash session inside the Docker project
 * Also handle the needed communication between the main and renderer threads
 */
let bashSession = (window, data) => {
  // Create the pty instance and set the docker project folder as the current working directory
  let process = PTY.spawn(Shell, [], {
    cwd: data.path,
    useConpty: false
  })

  // Immediately attempt to execute the command of executing `bash` inside the first Cassandra's node container
  process.write(`docker-compose -p "${data.projectID}" exec "cassandra-0" /bin/bash` + NewLineChar)

  // When receiving any data from the instance send it to the provided window
  process.on('data', (_data) => window.webContents.send(`pty:${data.id}:data:bash-session`, _data))

  // When receiving a commad to be executed from te renderer thread
  data.IPCMain.on(`pty:${data.id}:command:bash-session`, (_, command) => {
    try {
      // Send the command to the pty instance
      process.write(command)
    } catch (e) {}
  })

  // When receiving a request to close the bash session
  data.IPCMain.on(`pty:${data.id}:close:bash-session`, (_, __) => {
    try {
      // Call the `destroy` function from the pty instance
      process.destroy()

      // Attempt to kill the pty instance process by its process ID
      Kill(process.pid, 'SIGKILL')
    } catch (e) {}
  })
}

module.exports = {
  Pty,
  testConnectionWithCluster,
  bashSession
}
