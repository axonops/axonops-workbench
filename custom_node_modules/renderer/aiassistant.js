/**
 * Module to handle the AI assistant answers' and all related processes
 *
 * Define the AI assistant answers' data file path
 */
const QuestionsPath = Path.join(__dirname, '..', '..', 'data', 'ai_assistant.json')

/**
 * Get all saved questions and their answers
 *
 * @Parameters:
 * {object} `callback` function that will be triggered with passing the saved questions
 *
 * @Return: {object} list of all saved questions
 */
let getQuestions = (callback) => {
  // If the path to the data file is not accessible then try to create a data file
  if (!pathIsAccessible(QuestionsPath)) {
    try {
      FS.writeFileSync(QuestionsPath, '')
    } catch (e) {
      return callback(null)
    }
  }

  // Read the data file
  let savedQuestions = FS.readFileSync(QuestionsPath, 'utf8')

  // Convert it to a JSON object or an empty array
  try {
    savedQuestions = JSON.parse(savedQuestions)
  } catch (e) {
    savedQuestions = []
  }

  // Return the final result
  callback(savedQuestions)
}

/**
 * Save an answered question
 *
 * @Parameters:
 * {string} `question` the question's content/value
 * {string} `questionID` the unique question's ID to be used
 * {integer} `questionDate` the timestamp of the question's asking date
 * {string} `answer` the answer's content/value
 * {integer} `answerDate` the timestamp of the answer's date
 * {object} `callback` function that will be triggered with passing the result of the saving process
 *
 * @Return: {boolean} whether or not the question has been saved
 */
let saveQuestion = (question, questionID, questionDate, answer, answerDate, callback) => {
  // If the data file does not exist or inaccessible then return `false` and skip the upcoming code
  if (!pathIsAccessible(QuestionsPath))
    return callback(false)

  // Get all saved questions
  getQuestions((questions) => {
    // Push the new answered question
    try {
      questions.push({
        id: questionID,
        question,
        questionDate,
        answer,
        answerDate
      })

      // Write the saved questions including the new one
      FS.writeFileSync(QuestionsPath, applyJSONBeautify(questions))

      // Call the callback function with the succcess flag
      callback(true)
    } catch (e) {
      // If something went wrong call the callback function with the failure flag
      callback(false)
    }
  })
}

/**
 * Delete a saved question
 *
 * @Parameters:
 * {string} `questionID` the ID of the question aimed to be deleted
 * {object} `callback` function that will be triggered with passing the result of deletion process
 *
 * @Return: {boolean} whether or not the question has been deleted
 */
let deleteQuestion = (questionID, callback) => {
  // If the data file does not exist or inaccessible then return `false` and skip the upcoming code
  if (!pathIsAccessible(QuestionsPath))
    return callback(false)

  // Get all saved questions
  getQuestions((questions) => {
    try {
      // Delete the aimed one
      questions = questions.filter((question) => question.id != questionID)

      // Write the new, updated version of the saved questions
      FS.writeFileSync(QuestionsPath, applyJSONBeautify(questions))

      // Call the callback function with the success flag
      callback(true)
    } catch (e) {
      // If something went wrong call the callback function with the failure flag
      callback(false)
    }
  })
}

module.exports = {
  getQuestions,
  saveQuestion,
  deleteQuestion
}
