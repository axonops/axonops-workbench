/**
 * Return all saved workspaces
 *
 * @Return: {object} list of saved workspaces
 */
let getWorkspaces = async () => {
  let workspaces = [] // Final object which be returned

  try {
    // Get all workspaces
    let savedWorkspaces = await FS.readFileSync(Path.join(__dirname, '..', '..', 'data', 'workspaces', 'workspaces.json'), 'utf8')

    // Convert the JSON content from string to object
    try {
      savedWorkspaces = JSON.parse(savedWorkspaces)
    } catch (e) {
      savedWorkspaces = []
    }

    // Update the returned object
    workspaces = savedWorkspaces

    // Loop through workspaces and get `clusters.json` file inside each one
    for (let workspace of workspaces) {
      try {
        // Define the current workspace path - default or custom -
        let folderPath = !workspace.defaultPath ? workspace.path : Path.join(__dirname, '..', '..', 'data', 'workspaces'),
          // Read `clusters.json` file of that workspace
          clusters = await FS.readFileSync(Path.join(folderPath, workspace.folder, 'clusters.json'), 'utf8')

        // Convert the JSON content from string to object
        try {
          clusters = JSON.parse(clusters)
        } catch (e) {
          clusters = []
        }

        // Save the clusters object in the workspace object
        workspace.clusters = clusters
      } catch (e) {}
    }
  } catch (e) {} finally {
    // Return workspaces
    return workspaces
  }
}

/**
 * Save a given workspace
 *
 * @Parameters:
 * {object} `workspace` the workspace's info and data to be saved
 *
 * @Return: {boolean} the saving process has succeeded or failed
 */
let saveWorkspace = async (workspace) => {
  // Saving process status: [-1: Duplication, 0: Not saved, 1: Saved]
  let status = 0

  try {
    // Get all workspaces
    let workspaces = await FS.readFileSync(Path.join(__dirname, '..', '..', 'data', 'workspaces', 'workspaces.json'), 'utf8')

    // Convert the JSON content from string to object
    try {
      workspaces = JSON.parse(workspaces)
    } catch (e) {
      workspaces = []
    }

    // Extract the workspace folder name from its given name and make sure the given name does not exist - no duplication -
    let folder = Sanitize(workspace.name),
      duplication = workspaces.find((workspace) => manipulateText(Sanitize(workspace.folder)) == manipulateText(Sanitize(folder)))

    // If the given name exists
    if (duplication != undefined)
      return status = -1 // Failed to save the cluster due to duplication

    // Push cluster info
    workspaces.push({
      ...workspace,
      folder
    })

    // Define the workspace folder path - will be created -
    let workspacePath = Path.join(__dirname, '..', '..', 'data', 'workspaces', folder)

    // If a chosen path has been provided then it'll be adopted instead of the default one
    if (!workspace.defaultPath)
      workspacePath = Path.join(workspace.path, folder)

    // Create the workspace folder
    await FS.mkdirSync(workspacePath)

    // Inside it, create the `clusters.json` file
    await FS.writeFileSync(Path.join(workspacePath, 'clusters.json'), '')

    // Update the `workspaces.json` file; by adding the new workspace
    await FS.writeFileSync(Path.join(__dirname, '..', '..', 'data', 'workspaces', 'workspaces.json'), applyJSONBeautify(workspaces))

    // Successfully saved
    status = 1
  } catch (e) {} finally {
    // Return the saving process status
    return status
  }
}

/**
 * Update a given workspace
 *
 * @Parameters:
 * {object} `workspace` the workspace's info and data to be saved
 *
 * @Return: {boolean} the updating process has succeeded or failed
 */
let updateWorkspace = async (workspace) => {
  // Updating process status: [false: Not updated, true: Updated]
  let status = false

  try {
    // Get all workspaces
    let workspaces = await FS.readFileSync(Path.join(__dirname, '..', '..', 'data', 'workspaces', 'workspaces.json'), 'utf8')

    // Convert the JSON content from string to object
    try {
      workspaces = JSON.parse(workspaces)
    } catch (e) {
      workspaces = []
    }

    // Extract the workspace folder name from its given name and get the workspace object by its original folder name
    let folder = Sanitize(workspace.name),
      targetWorkspace = workspaces.find((_workspace) => manipulateText(Sanitize(_workspace.folder)) == manipulateText(Sanitize(workspace.originalFolder)))

    // Update workspace data
    targetWorkspace = {
      ...targetWorkspace, // Original data (like ID)
      name: workspace.name, // New workspace name
      color: workspace.color, // New color
      folder // And new folder name
    }

    // Define the default path
    let defaultPath = Path.join(__dirname, '..', '..', 'data', 'workspaces'),
      // Get the original path - before updating it -
      originalFolderPath = !targetWorkspace.defaultPath ? targetWorkspace.path : defaultPath,
      originalPath = Path.join(originalFolderPath, workspace.originalFolder),
      // Get the new path - after updating it -
      newFolderPath = !workspace.extra.defaultPath ? workspace.extra.path : defaultPath,
      newPath = Path.join(newFolderPath, folder)

    /**
     * Move the entire workspace from its original path to the new one
     * Allow overwriting if the path exists
     */
    try {
      await FS.moveSync(originalPath, newPath, {
        overwrite: true
      })
    } catch (e) {}

    // Now update workspace default path and path info
    targetWorkspace.defaultPath = workspace.extra.defaultPath

    // This attribute will be deleted if exists and it'll be added again if the new data has a custom path instead of the default one
    delete targetWorkspace.path
    if (!workspace.extra.defaultPath)
      targetWorkspace.path = workspace.extra.path

    // Update the workspaces' object by replacing the workspace's info with the new one
    workspaces = workspaces.map((workspace) => workspace.id != targetWorkspace.id ? workspace : targetWorkspace)

    // Write the new workspaces JSON object
    await FS.writeFileSync(Path.join(__dirname, '..', '..', 'data', 'workspaces', 'workspaces.json'), applyJSONBeautify(workspaces))

    // Successfully updated
    status = true
  } catch (e) {} finally {
    // Return the updating process status
    return status
  }
}

/**
 * Delete a given workspace
 *
 * @Parameters:
 * {object} `workspace` the target workspace's object
 * {object} `workspaces` an array of all saved workspaces
 *
 * @Return: {boolean} the deletion process's status
 */
let deleteWorkspace = async (workspace, workspaces) => {
  // Deletion process status: [false: Not deleted, true: deleted]
  let status = false

  try {
    // Define workspace folder path
    let folderPath = !workspace.defaultPath ? workspace.path : Path.join(__dirname, '..', '..', 'data', 'workspaces'),
      workspaceFolderPath = Path.join(folderPath, workspace.folder)

    // Remove the entire workspace folder; including all sub files and folders and make sure to force that process
    try {
      await FS.rmSync(workspaceFolderPath, {
        recursive: true,
        force: true
      })
    } catch (e) {
      // If any error has occurred then stop the deletion process with a failure
      return status
    }

    // Filter workspaces object by removing the deleted workspace and getting rid of the `clusters` object
    workspaces = workspaces
      .filter((_workspace) => _workspace.folder != workspace.folder)
      .map((_workspace) => {
        delete _workspace.clusters
        return _workspace
      })

    // Write the new workspaces object
    await FS.writeFileSync(Path.join(__dirname, '..', '..', 'data', 'workspaces', 'workspaces.json'), applyJSONBeautify(workspaces))

    // Successfully deleted
    status = true
  } catch (e) {} finally {
    // Return the deletion process status
    return status
  }
}

module.exports = {
  getWorkspaces,
  saveWorkspace,
  updateWorkspace,
  deleteWorkspace
}
